#include "logger.h"
#include <sys/types.h>
#include <sys/ipc.h> //key_t and ftok
#include <sys/shm.h> // shmctl, shmget, shmat, shmdt

/*
typedef __key_t key_t;
# define __key_t_defined

 Generates key for System V style IPC.
extern key_t ftok (const char *__pathname, int __proj_id) __THROW;



 Shared memory control operation.
extern int shmctl (int __shmid, int __cmd, struct shmid_ds *__buf) __THROW;

 Get shared memory segment.
extern int shmget (key_t __key, size_t __size, int __shmflg) __THROW;

 Attach shared memory segment.
extern void *shmat (int __shmid, const void *__shmaddr, int __shmflg)
     __THROW;

 Detach shared memory segment.
extern int shmdt (const void *__shmaddr) __THROW;
*/

#define GENERATE_KEY 'K'
#define PATH_KEY "/home/gen5/LEARN-FOR-FAST-TRACK/shared-memory-ipc/generate-key"
#define PATH_KEY_1 "/home/gen5/LEARN-FOR-FAST-TRACK/shared-memory-ipc/generate-key-1"


struct DYDX{
    int priceCurrent = 0;
    int* priceFuture = nullptr;
};

int main(int argc, char *argv[])
{
    LOG << "main start create share mem !";
    LOG << "size of DYDX: " << sizeof(DYDX);


    // tạo key_t cho share mem thứ nhất
    key_t key = ftok(PATH_KEY, GENERATE_KEY);
    if(key == -1){
        LOG << "path is not exist";
    }
    else{
        LOG << "key is: " << key;
    }

    // tạo vùng share mem thứ nhất và trả về định danh
    int shmid;
    shmid = shmget(key, sizeof(DYDX), 0666|IPC_CREAT|IPC_EXCL); // nếu tồn tại 1 cái vùng share mem với cái key kia rồi, thì return -1
    LOG << "shmid is: " << " " << shmid;

    // trả về 1 con trỏ chọc vào cái vùng nhớ có cái mã định danh là shmid
    DYDX* ptr_share = (DYDX*)shmat(shmid, nullptr, 0);
    ptr_share->priceCurrent = 93;

    // bên dưới in ra null vì trong cái vùng share đấy hiện tại chỉ có int* p, chứ k hề có cái vùng nhớ nào cho p trỏ đến (nhớ lại: int* p = new int() -> con trỏ p nằm trong stack trỏ đến 1 thằng nằm trên heap, vì dụ câu lệnh trên đặt ở trong function, thì ra khỏi function,nếu k return về 1 cái gì đó để giữ lại con trỏ, con trỏ p trên stack bị hủy còn vùng trên heap thì ko -> leak ) 
    
    if(ptr_share->priceFuture == nullptr){
        LOG << "null ptr int"; // nó in ra null ptr in này
    }
    else{
        LOG << "no null ptr int";
    }

    // tạo key_t cho share mem thứ hai, là cho con trỏ trong struct ý
    key_t key1 = ftok(PATH_KEY_1, GENERATE_KEY);
    if(key1 == -1){
        LOG << "path is not exist";
        return 0;
    }
    else{
        LOG << "key1 is: " << key1;
    }

    // tạo vùng share mem thứ hai và trả về định danh
    int shmid1;
    shmid1 = shmget(key1, sizeof(int), 0666|IPC_CREAT|IPC_EXCL);
    LOG << "shmid1 is: " << " " << shmid1;

    ptr_share->priceFuture = (int*)shmat(shmid1, nullptr, 0); // đã trỏ đến 1 vùng share mem nào đó
    if(ptr_share->priceFuture == nullptr){
        LOG << "null ptr int";
    }
    else{
        LOG << "no null ptr int"; // nó in ra no null
    }


    *(ptr_share->priceFuture) = 1998;
    LOG << ptr_share->priceCurrent << " " << *(ptr_share->priceFuture);

    // detach ra khỏi cái process này
    shmdt(ptr_share->priceFuture);
    shmdt(ptr_share);
    // LOG << ptr_share << " - " << "main end create share mem !";
    return 0;
}

==============================================================================================================================

#include "logger.h"
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <fcntl.h>
#include <iostream>

#define GENERATE_KEY 'K'
#define PATH_KEY "/home/gen5/LEARN-FOR-FAST-TRACK/shared-memory-ipc/generate-key"
#define PATH_KEY_1 "/home/gen5/LEARN-FOR-FAST-TRACK/shared-memory-ipc/generate-key-1"

typedef struct DYDX{
    int priceCurrent = 0;
    int* priceFuture = nullptr;
} DYDX;

int main(int argc, char *argv[])
{
    LOG << "main start use share mem !";

    // tạo lại key_t hoặc lấy luôn giá trị được tạo ra từ thằng create_share_mem
    key_t key = ftok(PATH_KEY, GENERATE_KEY);
    if(key == -1){
        LOG << "path is not exist";
    }
    else{
        LOG << "key is: " << key;
    }

    // gen lại mã định danh
    int shmid;
    shmid = shmget(key, nullptr, 0); // vì là lấy định danh của vùng share mem được liên kết với key, vùng này đã tồn tại rồi, nên tham số 2, 3 là 0 hoặc shmget(key, nullptr, 0666) <- ok hơn
    LOG << "shmid is: " << " " << shmid;

    // chọc vào vùng share mem đó
    DYDX* ptr_share = (DYDX*)shmat(shmid, nullptr, 0);

    // vì bên create_share_mem mình đã gán con trỏ p trong struct tới 1 vùng nhớ int mình tạo ra bên đó, nên bây giờ nó k phải là null nữa đâu
    if(ptr_share->priceFuture == nullptr){
        LOG << "null ptr int";
    }
    else{
        LOG << "no null ptr int"; // nó in ra là no null
    }

    // dù no null, nhưng phải có các bước bên tương tự, nếu không, vùng share mem thứ 2 đó vẫn ko hề được sử dụng trong process này, chọc đến vẫn cứ crash
    key_t key1 = ftok(PATH_KEY_1, GENERATE_KEY);
    if(key1 == -1){
        LOG << "path is not exist";
        return 0;
    }
    else{
        LOG << "key1 is: " << key1;
    }

    int shmid1;
    shmid1 = shmget(key1, 0, 0);
    LOG << "shmid1 is: " << " " << shmid1;

    ptr_share->priceFuture = (int*)shmat(shmid1, nullptr, 0);

    LOG << ptr_share->priceCurrent << " " << *(ptr_share->priceFuture);

    // dùng xong rồi thì hủy vùng share mem đó đi
    shmctl(shmid1, IPC_RMID, nullptr); // IPC_RMID - remove định danh của vùng nhớ, xóa hẳn vùng nhớ này luôn
    shmctl(shmid, IPC_RMID, nullptr);
    return 0;
}



